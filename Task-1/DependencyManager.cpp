#include "DependencyManager.h"#include <unordered_set>#include <vector>#include <stack>void DependencyManager::registerFile(const std::string& fileName) {    if (dependencyGraph.find(fileName) == dependencyGraph.end()) {        dependencyGraph[fileName] = {};    }}void DependencyManager::addDependency(const std::string& from, const std::string& to) {    dependencyGraph[from].insert(to);}std::vector<std::string> getTopologicalOrder(const std::unordered_map<std::string, std::set<std::string>>& graph) {    std::unordered_set<std::string> visited;    std::vector<std::string> sortedFiles;    std::stack<std::string> nodesToVisit;    std::unordered_set<std::string> currentStack;    for (const auto& [file, _] : graph) {        if (!visited.count(file)) {            nodesToVisit.push(file);            while (!nodesToVisit.empty()) {                std::string node = nodesToVisit.top();                if (!visited.count(node)) {                    visited.insert(node);                    currentStack.insert(node);                    if (graph.count(node)) {                        for (const auto& neighbor : graph.at(node)) {                            if (currentStack.count(neighbor)) {                                throw std::runtime_error("Cyclic dependency detected");                            }                            if (!visited.count(neighbor)) {                                nodesToVisit.push(neighbor);                            }                        }                    }                } else {                    nodesToVisit.pop();                    currentStack.erase(node);                    sortedFiles.push_back(node);                }            }        }    }    return sortedFiles;}std::vector<std::string> DependencyManager::getOrderedFiles() const {    return getTopologicalOrder(dependencyGraph);}